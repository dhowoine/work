---
# Front matter
title: "Отчёт по лабораторной работе №2"
author:
  - "Студент: Майорова О.А., НФИмд-02-21"
  - "Преподаватель: д.ф.-м.н. Кулябов Д.С."
date: "Москва 2021"

# Generic otions
lang: ru-RU
toc-title: "Содержание"

# Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

# Pdf output format
toc: true # Table of contents
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt

## I18n
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
### Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
  
## Misc options
indent: true
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
  - \usepackage{titling}
  - \setlength{\droptitle}{-9em}
  - \pretitle{\begin{center}
      \textbf{РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ}\\
      \textbf{Факультет физико-математических и естественных наук}\\
      \textbf{Кафедра прикладной информатики и теории вероятностей}
      \vspace{9cm}
      \LARGE\\}
  - \posttitle{\vskip 1em \large \emph{\textit{Дисциплина$:$ Математические основы защиты информации и информационной безопасности}} \end{center}}
  - \preauthor{\vskip 3em \begin{flushright} \large \begin{tabular}[t]{c}}
  - \postauthor{\end{tabular}\par\end{flushright} \vfill \vskip 5em}
---

# Цель работы

Цель: Ознакомиться с шифрами перестановки на примере маршрутного шифрования, шифрования с помощью решёток и шифра Виженера.

# Задание

Программно реализовать маршрутное шифрование, шифрование с помощью решёток и шифр Виженера.

# Теоретическое введение

Шифр перестановки — класс методов шифрования,  в котором элементы исходного открытого текста меняют местами по определённому правилу.
Элементами текста могут быть отдельные символы (самый распространённый случай), пары букв, тройки букв, комбинирование этих случаев и так далее.
Типичными примерами перестановки являются анаграммы. В классической криптографии шифры перестановки можно разделить на два класса:

- Шифры одинарной (простой) перестановки — при шифровании символы открытого текста перемещаются с исходных позиций в новые один раз;
- Шифры множественной (сложной) перестановки — при шифровании символы открытого текста перемещаются с исходных позиций в новые несколько раз.

Далее мы рассмотрим маршрутное шифрование, шифрование с помощью решёток, которые являются шифрами простой перестановки и шифр Виженера, который на самом деле является шифром замены [@cypher;@Vigenere].

Простейшим примеров перестановочного шифра являются так
называемые «маршрутные перестановки», использующие некоторую геометрическую фигуру
(плоскую или объемную). Шифрование заключается в том, что текст записывается в такую
фигуру по некоторой траектории, а выписывается по другой траектории. Пример —
маршрутные шифры перестановки, основанные на прямоугольниках (таблицах). Шифруемое
сообщение в этом случае записывается в прямоугольную таблицу по маршруту: по
горизонтали, начиная с верхнего левого угла, поочередно слева направо. 
Шифрованное сообщение записывается, например, по маршруту: по вертикалям,
начиная с верхнего левого угла, поочередно сверху вниз [@infw].

Шифрования с помощью решёток - метод шифрования, использующий для шифрования открытого текста трафарет с прорезями-ячейками.
Самый ранний из известных таких инструментов — решётка Кардано, датируемая 1550 годом, в ней использовался прямоугольный трафарет, позволяющий писать отдельные буквы, слога или слова,
а затем читать их через специальные прорези-ячейки. Письменные фрагменты открытого текста дополнительно маскировались тем, что промежутки между шифруемыми фрагментами заполнялись ничего
не означающими словами или буквами. Этот вариант является также примером стеганографии [@grid].
Решетка Кардано (поворотная решетка) — это прямоугольная или квадратная карточка с четным числом строк и столбцов.
В ней проделаны отверстия таким образом, что при последовательном отражении или поворачивании и заполнении открытых клеток карточки постепенно будут заполнены все клетки листа.
Карточку сначала отражают относительно вертикальной оси симметрии, затем — относительно горизонтальной оси, и снова — относительно вертикальной.
Если решетка Кардано — квадратная, то возможен и другой вариант ее преобразований — поворот на 90°.
Получатель должен знать трафарет и наложить его в той же последовательности, что и при шифровании. Ключом является выбранный тип перемещения решетки (отражение или поворот) и трафарет — расположение отверстий [@Cardan].

Шифр Виженера — метод полиалфавитного шифрования буквенного текста с использованием ключевого слова.
Шифр Виженера состоит из последовательности нескольких шифров Цезаря с различными значениями сдвига. Для зашифровывания может использоваться таблица алфавитов, называемая квадрат или таблица Виженера.
Применительно к латинскому алфавиту таблица Виженера составляется из строк по 26 символов, причём каждая следующая строка сдвигается на несколько позиций. Таким образом, в таблице получается 26 различных шифров Цезаря (табл. [-@tbl:Vigenere]).

: Таблица Виженера {#tbl:Vigenere}

| A | B | C | D | E | F | G | H | I | J | ... | Q | R | S | T | U | V | W | X | Y | Z |
|---|---|---|---|---|---|---|---|---|---|-----|---|---|---|---|---|---|---|---|---|---|
| B | C | D | E | F | G | H | I | J | K | ... | R | S | T | U | V | W | X | Y | Z | A |
| C | D | E | F | G | H | I | J | K | L | ... | S | T | U | V | W | X | Y | Z | A | B |
| D | E | F | G | H | I | J | K | L | M | ... | T | U | V | W | X | Y | Z | A | B | C |
|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|...|
| Z | Y | X | W | V | U | T | S | R | Q | ... | J | I | H | G | F | E | D | C | B | A |

Если $n$ - количество букв в алфавите, $m_j$ - — номер буквы открытого текста, $k_j$ — номер буквы ключа в алфавите, то шифрование Виженера можно записать следующим образом:

$c_j = (m_j + k_j) \mod n$

И расшифровывание:

$m_j = (c_j + n - k_j) \mod n$

Проще говоря, расшифровывание производится следующим образом: находим в таблице Виженера строку, соответствующую первому символу ключевого слова, и в данной строке находим первый символ зашифрованного текста.
Столбец, в котором находится данный символ, соответствует первому символу исходного текста. Следующие символы зашифрованного текста расшифровываются подобным образом [@Vigenere].

# Выполнение лабораторной работы
Для выполнения лабораторной работы был выбрат язык Python. Перед началом работы подключим библиотеку numpy:
```
import numpy as np
```
## Маршрутное шифрование
Сначала реализуем метод маршрутного шифрования для русского алфавита нижнего регистра:
```
# C - исходный текст
# p - пароль

def route(C, p):
    C = C.replace(' ', '')
    n = len(p)
    m = int(np.ceil(len(C) / n))
    
    for i in range(m*n - len(C)):
        C += chr(np.random.randint(ord('а'), ord('я') + 1))
    
    tbl = np.array(list(C)).reshape(m, n)
    
    r = p
    cypher = ''
    for i in range(n):
        idx = p.index(min(r))
        r = r.replace(min(r), '')
        cypher += ''.join(tbl[:, idx])
        
    return cypher
```
Результатом запуска функции для примера из задания к лабораторной работе будет рис. [-@fig:route].

![Проверка функции маршрутного шифрования](image/route.png){ #fig:route width=100% }

Можно видеть, что полученное зашифрованное сообщение длиннее приведённого в задании, однако, можно заметить, что длина всё же совпадает с длиной исходного текста.
Таким образом, шифрование функцией было произведено корректно.

## Шифрование с помощью решёток
Теперь реализуем шифрование с помощью решёток для заданных исходного текста и пароля в виде следующей функции:
```
# C - исходный текст
# p - пароль

def grid(C, p):
    C = C.replace(' ', '')
    k = int(np.ceil(len(p) / 2))
    
    sq1 = np.arange(k**2).reshape((k, k)) + 1
    sq2 = np.rot90(sq1, axes=(1, 0))
    sq3 = np.rot90(sq1, k=2, axes=(1, 0))
    sq4 = np.rot90(sq1, k=3, axes=(1, 0))
    
    tbl = np.vstack((np.hstack((sq1, sq2)), np.hstack((sq4, sq3))))
    
    for s in range(k**2):
        shot = np.random.randint(0, 4)
        idx, jdx = np.argwhere(tbl == s+1)[shot]
        tbl[idx, jdx] = 0
        
    cyph_tbl = np.empty([2*k, 2*k], dtype=str)
    for i in range(4):
        for j in range(k**2):
            idx, jdx = np.argwhere(tbl == 0)[j]
            cyph_tbl[idx, jdx] = C[j]
            
        C = C[k**2:]
        tbl = np.rot90(tbl, axes=(1, 0))
        
    r = p
    cypher = ''
    for i in range(len(p)):
        idx = p.index(min(r))
        r = r.replace(min(r), '')
        cypher += ''.join(cyph_tbl[:, idx])
    
    return cypher
```
Результатом запуска функции для примера из задания к лабораторной работе будет рис. [-@fig:grid1].

![Проверка функции шифрования с помощью решёток 1](image/grid1.png){ #fig:grid1 width=100% }

Можно видеть, что полученное зашифрованное сообщение отличается от приведённого в задании, однако, это объясняется тем, что задание "отверстий" в трафарете осуществляется на основе случайности.
На рис. [-@fig:grid2] можно видеть результат ещё одного запуска функции для тех же вводных данных.

![Проверка функции шифрования с помощью решёток 2](image/grid2.png){ #fig:grid2 width=100% }

Таким образом, шифрование функцией было произведено корректно.

## Шифр Виженера
Наконец, реализуем шифр Виженера. Сперва модифицируем функцию из предыдущей лабораторной работы, реализующую шифр Цезаря, для русского алфавита нижнего регистра:
```
# c - буква для шифрования
# k - ключ

def Caesar(c, k):
    n = [(i + k) % 33 for i in range(33)][ord(c) - ord('а')]
    return chr(ord('а') + n)
```
Далее напишем новую функцию, реализующую непосредственно шифр Виженера, которая будет использовать функцию Caesar:
```
# C - исходный текст
# p - пароль

def Vigenеre(C, p):
    C = C.replace(' ', '')
    P = ''
    for i in range(int(np.floor(len(C)/len(p)))):
        P += ''.join(p)
    P += ''.join(p[:len(C)%len(p)])
    
    cypher = ''
    for i in range(len(C)):
        k = ord(P[i]) - ord('а')
        cypher += ''.join(Caesar(C[i], k))
    
    return cypher
```
Проверим работу функции на примере из задания к лабораторной работе (рис. [-@fig:Vigenere]).

![Проверка функции шифра Виженера](image/Vigenere.png){ #fig:Vigenere width=100% }

Можно видеть, что полученное зашифрованное сообщение отличается от приведённого в задании, однако, это объясняется тем, что исходные алфавиты, использованные в тексте задания и при реализации функции,
отличаются на одну букву - "ъ". В задании к лабораторной работе "ъ" отсутствует.
Таким образом, шифрование функцией было произведено корректно.

# Выводы

Таким образом, была достигнута цель, поставленная в начале лабораторной работы. Было осуществлено знакомство с шифрами перестановки на примере
маршрутного шифрования, шифрования с помощью решёток и шифра Виженера. Также были получены реализации данных шифров на языке Python:

- реализация шифрования с помощью решёток для заданного пароля;
- реализации маршрутного шифрования и шифра Виженера для русского алфавита нижнего регистра.

# Список литературы{.unnumbered}

::: {#refs}
:::
